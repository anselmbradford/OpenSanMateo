<?php
/**
 * @file
 *
 * When enabled and configured, provides vocabulary synchronization support between a master site and client sites
 */

require_once('taxonomy_sync.constants.inc');
define('TAXONOMY_SYNC_MASTER_PREFIX', 'taxonomy_sync_is_master_for_');
define('TAXONOMY_SYNC_CLIENT_PREFIX', 'taxonomy_sync_is_client_for_');

class TaxonomySyncMissingVocabulary extends Exception { }
class TaxonomySyncNoServer extends Exception { }
class TaxonomySyncRequestFail extends Exception { }
class TaxonomySyncNoLocal extends Exception { }
class TaxonomoySyncFailedMerge extends Exception { }
class TaxonomySyncDeleteFailedDelete extends Exception { }
/**
 * Implementation of hook_menu()
 */
function taxonomy_sync_menu() {
  $items = array();

  $items['admin/config/system/gta-terms-sync'] = array(
    'title' => 'GTA Terms Synchronization',
    'description' => 'Configuration settings that control synchronizing a global vocabulary between a master and client sites',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_sync_admin_form'),
    'file' => 'taxonomy_sync.admin.inc',
    'access arguments' => array('administer site configuration'),
  );

  $items['taxonomy-sync/list/%'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'taxonomy_sync_list',
    'page arguments' => array(2),
    'access callback' => 'taxonomy_sync_list_access',
    'access arguments' => array(2),
  );

  return $items;
}

/**
 * access callback for list pages
 */
function taxonomy_sync_list_access($name) {
  $is_master = taxonomy_sync_is_master($name);
  if(!$is_master) {
    $client_ip = $_SERVER["REMOTE_ADDR"];
    watchdog(TAXONOMY_SYNC_WATCHDOG, 'Term list requested for non-master vocabulary @name by client @client_ip', array('@name' => $name, '@client_ip' => $client_ip), WATCHDOG_WARNING);
  }
  return $is_master;
}

/**
 * Menu callback to generate list of terms for client request
 */
function taxonomy_sync_list($name) {
  $payload = array(
    'name' => $name,
    'tree' => FALSE,
    'error' => FALSE,
    'error message' => '',
  );
  try {
    $payload['tree'] = taxonomy_sync_get_tree($name);
  }
  catch (TaxonomySyncMissingVocabulary $e) {
    watchdog(TAXONOMY_SYNC_WATCHDOG, 'Term list requested for non-existent vocabulary @name by client @client_ip', array('@name' => $name, '@client_ip' => $client_ip), WATCHDOG_WARNING);
    $payload['error message'] = $e->message;
    $payload['error'] = 'TaxonomySyncMissingVocabulary';
  }
  drupal_json_output($payload);
}

/**
 * return if this site is the master for the named vocabulary
 * PARAM name: machine name of a vocabulary
 * RETURN bool
 */
function taxonomy_sync_is_master($name) {
  return variable_get(TAXONOMY_SYNC_MASTER_PREFIX . $name, FALSE);
}

/*
 * Function to pull a tree of data on a machine name
 */
function taxonomy_sync_get_tree($name) {
   if($voc = taxonomy_vocabulary_machine_name_load($name)) {
     $tree = taxonomy_get_tree($voc->vid);
     return $tree;
   }
   else {
    throw TaxonomySyncMissingVocabulary("No vocabulary $name");
   }
}



/**
 * return if this site is the master for the named vocabulary
 * PARAM name: machine name of a vocabulary
 * RETURN bool
 */
function taxonomy_sync_get_master($name) {
  $url = variable_get(TAXONOMY_SYNC_CLIENT_PREFIX . $name, FALSE);
  if($url) { 
    return $url;
  }
  else {
    throw TaxonomySyncNoServer("No Master for $name");
  }
}
function taxonomy_sync_init() {
  $json = '{"name":"subject","tree":[{"tid":"20","vid":"2","name":"asubject2","description":"","format":"filtered_html","weight":"1","depth":0,"parents":["0"]},{"tid":"4","vid":"2","name":"subject2-asub1","description":"","format":"filtered_html","weight":"0","depth":1,"parents":["3"]},{"tid":"1","vid":"2","name":"subject1","description":null,"format":null,"weight":"2","depth":0,"parents":["0"]}],"error":false,"error message":""}';
  $data = drupal_json_decode($json, FALSE);
  #taxonomy_sync_sync($data['tree'], 'subject');

}
/**
 * sync a vocabularies terms
 */
function taxonomy_sync_sync($data, $vocabulary) {
  $sync = new TaxonomySyncData($data, $vocabulary);
  $sync->process();
}
function taxonomy_sync_pull_data($vocabulary) {

  $json = '{"name":"subject","tree":[{"tid":"20","vid":"2","name":"asubject2","description":"","format":"filtered_html","weight":"1","depth":0,"parents":["0"]},{"tid":"4","vid":"2","name":"subject2-asub1","description":"","format":"filtered_html","weight":"0","depth":1,"parents":["3"]},{"tid":"1","vid":"2","name":"subject1","description":null,"format":null,"weight":"2","depth":0,"parents":["0"]}],"error":false,"error message":""}';
  $data = drupal_json_decode($json, FALSE);
  $sync = new TaxonomySyncData($data['tree'], 'subject');
  $sync->process_inserts();
  $sync->process_updates();
  $sync->process_deletes();

  return;
  $url = FALSE;
  try {
    $url = $taxonomy_sync_get_master($name);
  }
  catch(TaxonomySyncNoServer $e) {
    throw $e;
  }
  // Now execute it
  $resp = drupal_http_request(taxonomy_sync_master_endpoint($url, $name));
  if (200 == $resp->code) {
    // Decode JSON and make sure we have a valid response
    $resp_array = drupal_json_decode($resp->data);
    if ($resp_array) {
      if ($resp_array['status']) {
        $master_terms = $resp_array['terms'];
        _taxonomy_sync_merge_terms($vid, $master_terms);
      }
      else {
        watchdog(TAXONOMY_SYNC_WATCHDOG, 'Request failed on master site with the message "@msg"', array('@msg' => $resp_array['msg']), WATCHDOG_WARNING);
      }
    }
    else {
      watchdog(TAXONOMY_SYNC_WATCHDOG, 'Failed to decode JSON data retrieved from master', NULL, WATCHDOG_WARNING);
    }
  }
  else if (403 == $resp->code) {
    throw TaxonomySyncMissingVocabulary("Master $url nodes not provide vocabulary $name");
  }
  else {
    throw TaxonomySyncRequestFail($resp->code);
  }
}

function taxonomy_sync_master_endpoint($url, $name, $op='list') {
  return "$url/taxonomy-sync/$op/$name";
}


/**
 * Implementation of hook_cron
 *
 * We're using this on the client side to pull from the master and merge into
 * the target vocabulary.
 */
function taxonomy_sync_cron_defunct() {
  // Pull our config vars
  $is_master = variable_get(TAXONOMY_SYNC_MASTER, FALSE);
  $vid = variable_get(TAXONOMY_SYNC_VOCAB, -1);
  $base_url = variable_get(TAXONOMY_SYNC_MASTER_URL, NULL);

  // Make sure we're defined as a client, return if not
  if ($is_master) {
    return;
  }

  // Check for valid config info
  if (empty($base_url)) {
    watchdog(TAXONOMY_SYNC_WATCHDOG, 'Base URL for master site not configured; unable to retrieve term list', NULL, WATCHDOG_WARNING);
    return;
  }
  $master_url = url($base_url . '/' . TAXONOMY_SYNC_CALLBACK_URL);

  if ($vid < 0) {
    watchdog(TAXONOMY_SYNC_WATCHDOG, 'Vocabulary not configured on client site', NULL, WATCHDOG_WARNING);
    return;
  }

  // Log this request
  watchdog(TAXONOMY_SYNC_WATCHDOG, 'Term list requested from %master_url', array('%master_url' => $master_url), WATCHDOG_INFO);

  // Now execute it
  $resp = drupal_http_request($master_url);
  if (200 == $resp->code) {
    // Decode JSON and make sure we have a valid response
    $resp_array = drupal_json_decode($resp->data);
    if ($resp_array) {
      if ($resp_array['status']) {
        $master_terms = $resp_array['terms'];
        _taxonomy_sync_merge_terms($vid, $master_terms);
      }
      else {
        watchdog(TAXONOMY_SYNC_WATCHDOG, 'Request failed on master site with the message "@msg"', array('@msg' => $resp_array['msg']), WATCHDOG_WARNING);
      }
    }
    else {
      watchdog(TAXONOMY_SYNC_WATCHDOG, 'Failed to decode JSON data retrieved from master', NULL, WATCHDOG_WARNING);
    }
  }
  else {
    watchdog(TAXONOMY_SYNC_WATCHDOG, 'Request failed, returned HTTP status code @code', array('@code' => $resp->code), WATCHDOG_WARNING);
  }
}

/**
 * _taxonomy_sync_merge_terms
 *
 * Function to merge terms from master site into target vocabulary.
 */
function _taxonomy_sync_merge_terms($vid, $master_terms) {
  // Get access to our stats variable
  $stats = &drupal_static(TAXONOMY_SYNC_STATS);
  $stats[TAXONOMY_SYNC_INSERT] = 0;
  $stats[TAXONOMY_SYNC_UPDATE] = 0;
  $stats[TAXONOMY_SYNC_DELETE] = 0;
  $stats[TAXONOMY_SYNC_UNCHANGED] = 0;

  // Load term sync history from our local table
  $local_terms = array();
  try {
    $query = db_select(TAXONOMY_SYNC_TABLE)
      ->fields(TAXONOMY_SYNC_TABLE)
      ->condition(TAXONOMY_SYNC_COL_LOCAL_VID, $vid);
    $result = $query->execute();
    $local_terms = $result->fetchAllAssoc(TAXONOMY_SYNC_COL_MASTER_TID, PDO::FETCH_ASSOC);
  }
  catch (Exception $e) {
    watchdog_exception(TAXONOMY_SYNC_WATCHDOG, $e);
  }

  // Now loop over our master terms looking for add and update operations
  foreach ($master_terms as $master_tid => $master_term) {
    // Construct our hash used to help weed out unchanged items
    $master_term[TAXONOMY_SYNC_COL_LAST_UPDATE_HASH] = md5(serialize($master_term));

    // Test for add operation
    if (!isset($local_terms[$master_tid])) {
      _taxonomy_sync_merge_term($vid, $master_term, $local_terms);
    }

    // Otherwise, it's an update operation if the hash doesn't match our last update
    elseif ($master_term[TAXONOMY_SYNC_COL_LAST_UPDATE_HASH] != $local_terms[$master_tid][TAXONOMY_SYNC_COL_LAST_UPDATE_HASH]) {
      _taxonomy_sync_merge_term($vid, $master_term, $local_terms, $local_terms[$master_tid][TAXONOMY_SYNC_COL_LOCAL_TID]);
    }

    // Otherwise this is an existing term that appears to have no changes on the master site
    else {
      ++$stats[TAXONOMY_SYNC_UNCHANGED];
    }
  }

  // Now check for deleted terms
  foreach ($local_terms as $master_tid => $local_term) {
    if (!isset($master_terms[$master_tid])) {
      _taxonomy_sync_delete_term($local_term);
    }
  }

  // Generate watchdog summary output
  watchdog(TAXONOMY_SYNC_WATCHDOG, 'Merge complete: @ins inserted, @up updated, @del deleted, @unch unchanged', array(
    '@ins' => $stats[TAXONOMY_SYNC_INSERT],
    '@up' => $stats[TAXONOMY_SYNC_UPDATE],
    '@del' => $stats[TAXONOMY_SYNC_DELETE],
    '@unch' => $stats[TAXONOMY_SYNC_UNCHANGED],
  ));
}

/**
 * _taxonomy_sync_merge_term
 *
 * Called to add or update a new term to the given vocabulary and log it in the local sync table
 */
function _taxonomy_sync_merge_term($vid, $master_term, &$local_terms, $local_tid = NULL) {
  // Get access to our stats variable
  $stats = &drupal_static(TAXONOMY_SYNC_STATS);

  // Extract and unset parents array from term; not being honored by term save code
  $master_parents = $master_term['parents'];
  unset($master_term['parents']);

  // Cast to object, modify using local info, set some reasonable defaults
  $term = (object) $master_term;
  $term->vid = $vid;
  $term->tid = $local_tid;
  $term->parent = 0;

  // Sync master term's first parent tid up to local tid, or 0 if no parent
  if (!empty($master_parents)) {
    $term->parent = (isset($local_terms[$master_parents[0]])) ? $local_terms[$master_parents[0]][TAXONOMY_SYNC_COL_LOCAL_TID] : 0;
  }

  // Save out term
  $result = taxonomy_term_save($term);
  if (SAVED_NEW == $result) {
    //watchdog(TAXONOMY_SYNC_WATCHDOG, __FUNCTION__ . ': Added: <br/><pre>' . print_r(array('term' => $term, 'master' => $master_term), TRUE) . '</pre>', NULL, WATCHDOG_DEBUG);
    // Update local terms
    $local_terms[$master_term['tid']] = array(
      TAXONOMY_SYNC_COL_MASTER_TID => $master_term['tid'],
      TAXONOMY_SYNC_COL_LOCAL_VID => $vid,
      TAXONOMY_SYNC_COL_LOCAL_TID => $term->tid,
      TAXONOMY_SYNC_COL_LAST_UPDATE_HASH => $master_term[TAXONOMY_SYNC_COL_LAST_UPDATE_HASH],
    );

    // Update our sync table
    drupal_write_record(TAXONOMY_SYNC_TABLE, $local_terms[$master_term['tid']]);
    ++$stats[TAXONOMY_SYNC_INSERT];
  }
  elseif (SAVED_UPDATED == $result) {
    //watchdog(TAXONOMY_SYNC_WATCHDOG, __FUNCTION__ . ': Updated: <br/><pre>' . print_r($term, TRUE) . '</pre>', NULL, WATCHDOG_DEBUG);
    // If successfully updated, update our sync table
    $record = array(
      TAXONOMY_SYNC_COL_LAST_UPDATE_HASH => $master_term[TAXONOMY_SYNC_COL_LAST_UPDATE_HASH],
      TAXONOMY_SYNC_COL_LOCAL_TID => $term->tid,
    );
    drupal_write_record(TAXONOMY_SYNC_TABLE, $record, TAXONOMY_SYNC_COL_LOCAL_TID);
    ++$stats[TAXONOMY_SYNC_UPDATE];
  }
  else {
    watchdog(TAXONOMY_SYNC_WATCHDOG, 'Failed to store term %name with master tid @tid in vocabulary @vid', array('%name' => $term->name, '@tid' => $master_term['tid'], '@vid' => $vid), WATCHDOG_WARNING);
  }
}

/**
 * _taxonomy_sync_delete_term
 *
 * Method to remove a term from the target vocabulary and the sync tables
 */
function _taxonomy_sync_delete_term($local_sync) {
  // Get access to our stats variable
  $stats = &drupal_static(TAXONOMY_SYNC_STATS);

  $tid = $local_sync[TAXONOMY_SYNC_COL_LOCAL_TID];
  $result = taxonomy_term_delete($tid);
  if (SAVED_DELETED == $result) {
    // If successfully deleted, update our sync table
    try {
      $query = db_delete(TAXONOMY_SYNC_TABLE)
        ->condition(TAXONOMY_SYNC_COL_LOCAL_TID, $tid)
        ->execute();
    }
    catch (Exception $e) {
      watchdog_exception(TAXONOMY_SYNC_WATCHDOG, $e);
    }
    ++$stats[TAXONOMY_SYNC_DELETE];
  }
  else {
    watchdog(TAXONOMY_SYNC_WATCHDOG, 'Failed to delete term @ltid with master tid @mtid in vocabulary @vid', array('@ltid' => $tid, '@mtid' => $local_sync[TAXONOMY_SYNC_COL_MASTER_TID], '@vid' => $vid), WATCHDOG_WARNING);
  }
}


/**
 * A class for handling the sync of Data from a a master to a slave 
 */
class TaxonomySyncData{
  public $master_data = array();
  public $vid;
  public $stats;
  public $updates = FALSE;
  public $inserts = FALSE;
  public $deletes = FALSE;
  public $cache_tid_map = array(0 => 0);
  public $cache_hash_map = FALSE;
  public $missing_parent = array();

  /**
   * constructor 
   * PARAM master_data: an array structure like a taxonomy_tree return
   * PARAM $vocabulary: a machine name or vid of the local vocabulary
   */
  function __construct($master_data, $vocabulary) {
    $this->set_master_data($master_data);
    $this->set_vid($vocabulary);
  }

  /**
   * set the vid for this obj, can be the vid or the machine name
   */
  protected function set_vid($vocabulary) {
    if(is_numeric($vocabulary)) {
      $this->vid = $vocabulary;
    }
    else {
      if($voc = taxonomy_vocabulary_machine_name_load($vocabulary)) {
        $this->vid = $voc->vid;
      }
      else {
        throw TaxonomySyncMissingVocabulary("No vocabulary $name");
      }
    }

  }

  /**
   * sets master data in an array keyed by master tid
   */
  protected function set_master_data($master_data) {
    foreach($master_data as $datum) {
      $datum = (object) $datum;
      $datum->TAXONOMY_SYNC_COL_LAST_UPDATE_HASH = $this->term_hash($datum);
      $this->master_data[$datum->tid] = $datum;
    }
  }

  /**
   * return all of the master tids that are to be processed
   */
  public function get_master_ids() {
    return array_keys($this->master_data);
  }

  /**
   * return a hash of a term
   */
  static function term_hash($term) {
    return md5(serialize($term));
  }

  /**
   * return a map of master tid to a hash
   */
  protected function get_hash_map() {
    if(!$this->cache_hash_map) {
      foreach($this->master_data as $id => $datum) {
        $this->cache_hash_map[$id] = $datum->TAXONOMY_SYNC_COL_LAST_UPDATE_HASH;
      }
    }
    return $this->cache_hash_map;
  }

  /**
   * returns and array of master tid => local tid that are canidates for updates
   */
  protected function get_update_ids() {
    if (!$this->updates) {
      $query = db_select(TAXONOMY_SYNC_TABLE, 't');
      $query->fields('t',array(TAXONOMY_SYNC_COL_MASTER_TID, TAXONOMY_SYNC_COL_LOCAL_TID));
      $query->condition(TAXONOMY_SYNC_COL_MASTER_TID, $this->get_master_ids(), 'IN');
      $query->condition(TAXONOMY_SYNC_COL_LAST_UPDATE_HASH, $this->get_hash_map(), 'NOT IN');
      $this->updates= $query->execute()->fetchAllKeyed();
    }
    return $this->updates;
  }

  /**
   * returns array of master ids for insertions
   */
  protected function get_insert_ids() {
    if (!$this->inserts) {
      $query = db_select(TAXONOMY_SYNC_TABLE, 't');
      $query->fields('t',array(TAXONOMY_SYNC_COL_MASTER_TID, TAXONOMY_SYNC_COL_LOCAL_TID));
      $query->condition(TAXONOMY_SYNC_COL_MASTER_TID, $this->get_master_ids(), 'IN');
      $existing = $query->execute()->fetchAllKeyed();
      $this->inserts = array_diff($this->get_master_ids(), array_keys($existing));
    }
    return $this->inserts;
  }

  /**
   * return array of Local tids for deletion
   */
  protected function get_delete_ids() {
    if (!$this->deletes){
      $query = db_select(TAXONOMY_SYNC_TABLE, 't');
      $query->fields('t', array(TAXONOMY_SYNC_COL_LOCAL_TID, TAXONOMY_SYNC_COL_LOCAL_TID));
      $query->condition(TAXONOMY_SYNC_COL_MASTER_TID, $this->get_master_ids(), 'NOT IN');
      $this->deletes = $query->execute()->fetchAllKeyed();
    }
    return $this->deletes;
  }


  public function process() {
    $this->process_inserts();
    $this->process_updates();
    $this->process_deletes();
    $this->process_missing_parents();
    $this->process_cleanup();
    return $this;
  }

  /**
   * remove all terms not managed by sync
   */
  public function process_cleanup() {
    $query = db_select('taxonomy_term_data', 't');
    $query->leftJoin(
      TAXONOMY_SYNC_TABLE, 
      's', 
        's.' . TAXONOMY_SYNC_COL_LOCAL_TID . ' = t.tid AND s.' . TAXONOMY_SYNC_COL_LOCAL_VID . ' = t.vid');
    $query->fields('t', array('tid', 'tid'));
    $query->condition('t.vid', $this->vid, '=');
    $query->isNull('s.' .TAXONOMY_SYNC_COL_LOCAL_VID);
    $results = $query->execute()->fetchAllKeyed();
    foreach($results as $tid) {
    #foreach($query->execute()->fetchAllKeyed() as $tid) {
      try {
        $this->delete_term($tid);
      }
      catch (TaxonomySyncDeleteFailedDelete $e) {
        watchdog_exception(TAXONOMY_SYNC_WATCHDOG, $e);
      }
    }
    
  
  }
  /**
   * process all updates
   */
  public function process_updates() {
    foreach($this->get_update_ids() as $master_id => $local_tid) {
      try {
        $this->merge_term($this->get_master_term($master_id), taxonomy_term_load($local_tid));
      }
      catch (TaxonomoySyncFailedMerge $e) {
        dpm($e->getMessage(), __FUNCTION__);
        watchdog_exception(TAXONOMY_SYNC_WATCHDOG, $e);
      }
    }
  }

  /**
   * process all inserts
   */
  public function process_inserts() {
    foreach($this->get_insert_ids() as $master_id) {
      try {
        $this->merge_term($this->get_master_term($master_id));
      }
      catch (TaxonomoySyncFailedMerge $e) {
        watchdog_exception(TAXONOMY_SYNC_WATCHDOG, $e);
      }
    }
  }

  /**
   * process all deletes
   */
  public function process_deletes() {
    foreach($this->get_delete_ids() as $tid) {
      try {
        $this->delete_term($tid);
      }
      catch (TaxonomySyncDeleteFailedDelete $e) {
        watchdog_exception(TAXONOMY_SYNC_WATCHDOG, $e);
      }
    }
  }

  /**
   * process all missing parents
   */
  public function process_missing_parents() {
    foreach($this->get_missing_parents_ids() as $master_id => $local_tid) {
      try {
        $this->merge_term($this->get_master_term($master_id), taxonomy_term_load($local_tid));
      }
      catch (TaxonomoySyncFailedMerge $e) {
        dpm($e->getMessage(), __FUNCTION__);
        watchdog_exception(TAXONOMY_SYNC_WATCHDOG, $e);
      }
    }
  }
  /**
   * return a master term object 
   */
  protected function get_master_term($id) {
    return $this->master_data[$id];
  }

  /**
   * get a local tid based on its maping to a master tid
   */
  protected function get_local_tid($master_tid) {
    if(!isset($this->cache_tid_map[$master_tid])) {
      $query = db_select(TAXONOMY_SYNC_TABLE, 't');
      $query->fields('t', array(TAXONOMY_SYNC_COL_LOCAL_TID));
      $query->condition(TAXONOMY_SYNC_COL_MASTER_TID, $master_tid, '=');
      $this->cache_tid_map[$master_tid] = $query->execute()->fetchField();
    }
    if(!$this->cache_tid_map[$master_tid] && $master_tid != 0) {
      throw new TaxonomySyncNoLocal("There is no local tid for master tid $master_tid");
    }
    return $this->cache_tid_map[$master_tid];
  }

  /**
   * record a record as missing a parent (needs to be rerun)
   */
  protected function add_missing_parent($master_tid) {
    $this->missing_parent[] = $master_tid;
  }

  /**
   * return an array of master to local tids that need to be run to update parents
   */
  protected function get_missing_parents_ids() {
    $map = array();
    foreach($this->missing_parent as $master_id) {
      $map[$master_id] = $this->get_local_tid($master_id);
    }
    return $map;
  }

  /**
   * Method to remove a term from the target vocabulary and the sync tables
   */
  protected function delete_term($local_tid) {
    $result = taxonomy_term_delete($local_tid);
    if (SAVED_DELETED == $result) {
      // If successfully deleted, update our sync table
      try {
        $query = db_delete(TAXONOMY_SYNC_TABLE)
          ->condition(TAXONOMY_SYNC_COL_LOCAL_TID, $local_tid)
          ->execute();
      }
      catch (Exception $e) {
        throw new TaxonomySyncDeleteFailedDelete($e->getMessage());
      }
    }
    else {
      $message = format_string('Failed to delete term @ltid with master tid @mtid in vocabulary @vid', array('@ltid' => $tid, '@mtid' => $local_sync[TAXONOMY_SYNC_COL_MASTER_TID], '@vid' => $vid));
      throw new TaxonomySyncDeleteFailedDelete($message);
    }
  }
  
  /**
   * method for merging a term from the master to the local, can be for updates or inserts
   */
  protected function merge_term($master_term, $local_term = NULL) {
    // Extract and unset parents array from term; not being honored by term save code
    $master_parents = isset($master_term->parents) ? $master_term->parents : $master_term->parent;
    $master_tid = $master_term->tid;
    unset($master_term->parents);

    //using local info, set some reasonable defaults
    $term = clone $master_term;
    $term->vid = $this->vid;
    $term->tid = isset($local_term) ? $local_term->tid: NULL;
    $term->parent = 0;

    // Sync master term's first parent tid up to local tid, or 0 if no parent
    if (!empty($master_parents)) {
      try {
        $term->parent = $this->get_local_tid($master_parents[0]);
        dpm($term);
      }
      catch (TaxonomySyncNoLocal $e) {
        dpm($term);
        $this->add_missing_parent($master_tid);
      }
    }
    // Save out term
    $result = taxonomy_term_save($term);
    $record = (object) array(
      TAXONOMY_SYNC_COL_MASTER_TID => $master_tid,
      TAXONOMY_SYNC_COL_LOCAL_VID => $this->vid,
      TAXONOMY_SYNC_COL_LOCAL_TID => $term->tid,
      TAXONOMY_SYNC_COL_LAST_UPDATE_HASH => $master_term->TAXONOMY_SYNC_COL_LAST_UPDATE_HASH,
    );
    dpm(array($term, $record));
    if (SAVED_NEW == $result) {
      drupal_write_record(TAXONOMY_SYNC_TABLE, $record);
      unset($this->cache_tid_map[$master_tid]);
    }
    elseif (SAVED_UPDATED == $result) {
      drupal_write_record(TAXONOMY_SYNC_TABLE, $record, TAXONOMY_SYNC_COL_LOCAL_TID);
    }
    else {
      throw new TaxonomoySyncFailedMerge(format_string('Failed to store term %name with master tid @tid in vocabulary @vid', array('%name' => $term->name, '@tid' => $master_tid, '@vid' => $this->vid)));
    }
  }
}

/**
 * Menu callback to generate list of terms for client request
 */
/*
function taxonomy_sync_list_defunct() {
  // Pull our config vars
  $is_master = variable_get(TAXONOMY_SYNC_MASTER, FALSE);
  $vid = variable_get(TAXONOMY_SYNC_VOCAB, -1);
  $client_ip = $_SERVER["REMOTE_ADDR"];

  // Make sure we're defined as a master, report if not
  if (!$is_master) {
    watchdog(TAXONOMY_SYNC_WATCHDOG, 'Term list requested from non-master site by client @client_ip', array('@client_ip' => $client_ip), WATCHDOG_WARNING);
    return MENU_NOT_FOUND;


  // Log this request
  watchdog(TAXONOMY_SYNC_WATCHDOG, 'Term list requested for vid @vid by client @client_ip', array('@vid' => $vid, '@client_ip' => $client_ip), WATCHDOG_INFO);

  // Build default return array
  $retval = array(
    'status' => TRUE,
    'terms' => array(),
    'msg' => '',
  );

  // Check config var for vocabulary id
  if ($vid < 0) {
    $retval['status'] = FALSE;
    $retval['msg'] = t('Vocabulary not configured on master site');
    $retval['terms'] = array();
  }
  else {
    // Query for full vocabulary "tree" and build response array
    $tree = taxonomy_get_tree($vid);
    if (!count($tree)) {
      watchdog(TAXONOMY_SYNC_WATCHDOG, 'Vocabulary requested is empty', NULL, WATCHDOG_WARNING);
    }
    else {
      foreach ($tree as $child) {
        $retval['terms'][$child->tid] = $child;
      }
    }
  }

  // Log any errors
  if (!$retval['status']) {
    watchdog(TAXONOMY_SYNC_WATCHDOG, $retval['msg'], NULL, WATCHDOG_WARNING);
  }

  // Construct JSON and return
  drupal_json_output($retval);
  exit;
}
}

*/

function taxonomy_sync_form_taxonomy_form_vocabulary_alter(&$form) {
  $name = $form['#vocabulary']->machine_name;
  $form['taxonomy_sync'] = array(
    '#type' => 'fieldset',
    '#title' => 'Taxonomy Sync',

  );
  $form['taxonomy_sync'][TAXONOMY_SYNC_MASTER_PREFIX . $name] = array(
    '#type' => 'checkbox',
    '#description' => t('Checking this box will expose this vocabulary for syncing at %url.', array('%url' => url("taxonomy-sync/list/$name", array('absolute'=>TRUE)))),
    '#default_value' =>  variable_get(TAXONOMY_SYNC_MASTER_PREFIX . $name, FALSE),
    '#title' => t("Is a Master Vocabulary"),

  );
  $form['#submit'][] = 'taxonomy_sync_form_taxonomy_form_vocabulary_sumbit';
  dpm($form);
}

function taxonomy_sync_form_taxonomy_form_vocabulary_sumbit($form, $form_state)  {
  dpm($form_state);
  $name = $form['#vocabulary']->machine_name;
  variable_set(TAXONOMY_SYNC_MASTER_PREFIX . $name, $form_state['values'][TAXONOMY_SYNC_MASTER_PREFIX . $name]);
}
